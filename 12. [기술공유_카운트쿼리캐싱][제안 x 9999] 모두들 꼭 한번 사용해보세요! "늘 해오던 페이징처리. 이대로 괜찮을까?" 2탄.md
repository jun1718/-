![image](https://user-images.githubusercontent.com/88138317/191444535-5af5fdf7-bbdb-4c40-81d2-a733f4d697a3.png)
# 목차

#### 1) 배경

#### 2) 1탄 내용회상

#### 3) 카운트쿼리 문제인식

#### 4) 성능개선 방법에 대한 고찰

#### 5) 적용

#### 6) 개선

#### 7) TableCount 관리방안

#### 8) 단점

#### 9) 마치며

# 1) 배경

* 반갑습니다. 1기 교육생 최겸준입니다\~! 1탄에서 커버링인덱스를 잘 적용했지만 여전히 남아있던 count 쿼리 문제가 있었습니다. 해당 하는 부분을 해결하기 위한 부분을 공유하기 위해 나머지를 작성합니다.

# 2) 1탄 내용회상

* 개선
    * 아래 두 사진을 비교해보시면 알수 있듯이 1탄에서 커버링 인덱스를 적용하여서 약 8배의 성능향상을 이루어 냈습니다.
    ![답변완료_28만_nocount_14.068.png](/files/3357111004497265261)
    ![답변완료_28만_2.417.png](/files/3357110703093794630)

# 3) 카운트쿼리 문제인식

* 여전히 남아있는 문제
하지만 아직 남아 있는 문제가 있었죠? 그것은 바로 카운트 쿼리입니다.
아래 사진은 해당 카운트 쿼리를 hibernate에서 생성한 것입니다.
![count추가쿼리.png](/files/3357120470795805288)
fetchCount()를 이용하여 카운트 쿼리를 구하고 totalpage를 표시했더니 성능저하가 발생했습니다.
아래 사진을 보시죠.
![답변완료_28만_3.943.png](/files/3357112380508144560)
위 사진을 보시면 기존 커버링 인덱스로 개선한 시간에 비해 1.5s 정도 성능이 저하된 것을 확인하실 수 있습니다.
* 추적
과연 저 문제가 카운트 쿼리의 문제가 맞았는가 확인할 필요가 있었습니다.
다른 문제는 없는가 확실히 파악해야지 하나만 파고들수 있었을테니까요.
그래서 mysql에서 count 쿼리의 성능을 추적해봤습니다.
![mysql에서count쿼리추적시간_1.422.png](/files/3357124419340581765)
위 사진과 같이 1.422s가 나왔습니다. 쿼리는 위에서 보여준 쿼리와 완전히 일치합니다.
다시 말해서, 카운트 쿼리로 인해 약 1.5s가 저하되었다는 사실이 증명되었습니다.

# 4) 성능개선 방법에 대한 고찰

* MORE
이 부분은 구글링하며 알아낸 정보였는데요 애초에 ui단에서 < 1/2 > 라는 페이징 ui가 나오지 않고
인스타 같은 부분에 나오는 것처럼 글을 읽으러 내려갈때 more를 클릭할때마다 내려가도록해서 count 쿼리를 계산하지 않고 오로지 page 정보로 값을 얻어내오는 방법이었습니다.
* 페이지 버튼박스
이 부분은 제가 생각해낸 방법이었는데요, MORE를 보고 영감을 얻어서 생각을 해낸 방법이었어요.
페이지 버튼들이 있으면 토탈페이지를 표시할 필요가 없어요. 그래서 항상 10개의 버튼을 고정되게 늘어놓고 존재하지 않는 페이지를 클릭했을때만 카운트쿼리를 발생시켜서 쿼리를 절약한다는 개념입니다.
* 페이징처리에서 현재페이지만 보이게하기
이 부분도 마찬가지로 more에 영감을 얻어서 생각해낸 방법으로 < 1 > 이런식으로 total page만 빼주면 count쿼리가 필요없게 되니 괜찮겠다 라는 생각을 했습니다.
* 하지만 이런 세가지 부분들 모두 ui를 조작해서 꼼수?를 사용하는 것 같은 느낌이 있습니다. 우리가 진정 벡엔드 개발자라면 이런 ui적인 부분을 고려해서 문제를 해결하는게 아니라, back에서 해결할 수 있어야겠죠? 그래서 이 글에서는 back적으로 해결해보았습니다.
* 방법은 캐싱입니다. 사실 캐싱이라는 말도 거창합니다.
단순히 특정 상황에 대한 total count를 저장하는 테이블을 하나 만들고 거기서 count 값을 유지하게 하는 것입니다. 그럼 재미없는 개념적인 얘기는 여기서 끝내고 table을 만들러 가봅시다!

# 5) 적용

* 테이블생성
![table생성.png](/files/3357118537181509644)
위 사진은 간단히 name과 count를 가지도록 하는 테이블을 만든 것입니다.
name에는 "고객문의답변완료개수"와 같은 값이 들어가고 count는 실제 상황에 대한 count 값이 들어갑니다.
* findByName이라는 메서드를 만들고 name 컬럼값을 통해서 TableCount를 반환받도록 합니다.
![service.png](/files/3357119203824361464)
위 사진처럼 서비스로 예외처리를 하지 않으면 매번 사용하는 곳마다 optional 예외 처리를 해야하기때문에 optional 예외를 검사해서 TableCount를 직접적으로 반환하는 서비스를 만들었습니다.
* QueryDsl로 넘어가기 직전코드
위에서 만든 서비스를 이용하여 TableCount를 불러옵니다. 이때 name은 본인이 필요한 상황에 맞게 insert했던 name(이를테면 고객문의답변완료개수)을 사용합니다. (현재 TableCount에는 필요한 개수가 들어있고 잘 관리되고 있다고 가정합니다.)
![메서드.png](/files/3357120051239831319)
* QueryDsl에 적용하기
고객문의답변완료에 대한 성능개선 학습만을 진행중이기에 if문으로 고객문의완료케이스가 들어온 경우에는 tableCount가 넘겨준 count를 사용합니다. 아래사진은 해당 코드입니다.
![메서드2.png](/files/3357122458804777709)
count를 직접적으로 받기때문에 아래에 있는 fetchCount가 동작하지 않습니다. 즉 1.5s에 해당하는 시간을 아꼈습니다.
아래 사진은 직접적으로 tableCount에 조회하는 쿼리입니다.
![쿼리_table에저장해둔count가지러가서가져오기.png](/files/3357129250154503825)
위 사진에서 보듯이 개수를 잘 바인딩 해오는 것을 확인하실 수 있습니다.

# 6) 개선

* 아래 사진을 보시면 알 수 있듯이 카운트에 소비되었던 1.5s가 줄어들어서 다시 성능이 개선됨을 확인 할 수 있습니다.
![답변완료_28만_2.316.png](/files/3357125265986697755)
자, 이제 이 글을 읽고계신 여러분들께서는 CRUD만 찍을줄 안다면 카운트성능까지도 확보할수 있게 되었습니다. 축하드립니다!

# 7) TableCount 관리방안

* 동기화
tabbleCount를 최초로 동기화하는 시점이 필요합니다. 그래서 저는 spring에서 제공하는 @Scheduler를 이용해서 시작되자말자 한번 쿼리를 날립니다. 그후에는 3시간에 한번식 값을 조회해서 동기화를 해줍니다.
![tableCount관리방안.png](/files/3357127595455961863)
(scheduled는 굉장히 간단한 개념입니다. 인터넷에 쳐보시면 매우 쉽게 내용을 접하실 수 있습니다. 여기서는 이전 작업이 종료되고 나면 3시간뒤에 다시 실행하라는 의미입니다.)
위 사진처럼 동기화를 해주지 않으면 값이 달라지는 현상이 발생할 수 있습니다. 사실 몇백만건씩 되는 데이터에 한두개의 데이터 개수가 달라지는 것은 크게 중요한 일은 아닙니다. 그래도 명확한 데이터를 확인하는 것이 좋으니 이 동기화 과정은 필요합니다. 그 시간은 각자에게 맞는 정책을 따르시면 됩니다.
* 동기화작업 실제로 두눈으로 직접 확실하게 보기
부트스트랩될때 값이 실행되었다면 count값이 update 되었을겁니다. 아래 사진은 부트스트랩당시에 @Scheduled에 의해 실행되는 코드입니다.
![실행됨터미널.png](/files/3357131923147730371)
위 사진은 log를 찍어 두었던 것이 잘 확인됩니다. count는 육천만개정도가 되는데 이는 280만개에서 데이터가 추가되어서 1탄과 값이 달라졌습니다.(1탄에서는 280만개를 가정하여 글을 작성하였음.)
![실행시update쿼리.png](/files/3357132050135279924)
위 사진은 얻어온 count 를 update에 잘 적용하고 있는 모습입니다.
* 동기화 후 처리
동기화가 된 후에도 고객문의 답변은 계속 추가될 수 있고 삭제될 수 도 있습니다.
문의가 삭제될 수도 있고 문의답변만 삭제될 수도 있습니다. 이런 경우의 수를 잘 산정하셔서 추가가 될때는 tableCount를 불러와서 더티체킹을 통해 기존의 count에서 1의 값을 추가해주고, 마이너스 될때 더티체킹을 통해 기존의 count에서 1을 마이너스해주는 로직을 넣어주시면 됩니다.

# 8) 단점

* 인덱스가 늘 그렇듯이 조회는 빠르지만 쓰기, 변경, 삭제에 약합니다. 매번 정렬하고 탐색에 테이블을 추가하거나 변경해야하기 때문이죠. 하지만 거기서 더하고 뺄때 추가로 tableCount에도 값을 추가해주고 빼는 로직을 추가해야합니다. 그러니 더더욱 쓰기, 변경, 삭제에 취약해집니다.
* 적에게 내어줄 살이 무엇인지 판단하고 적에게 얻을 뼈를 취하십시오. 그 뼈는 당신의 애플리케이션 구조를 더욱 더 풍성하고 단단하게 만들어줄 것입니다.

# 9) 마치며

* 사실 발표준비나 인터뷰 준비하느라고 너무 바빠서 count 쿼리에 관한 기술공유는 다음에 시간이 지나서 하려고 했습니다. 하지만 생각해보니 다들 발표 및 인터뷰가 끝나고나서 기술공유를 하면 그게 의미가 많이 무색해지지 않겠나 싶은 생각에 어느정도 시간지연을 감수해서라도 기술공유 하기로 마음먹었고 맘먹은대로 바로 해당 글을 작성하였습니다.
* 내용 자체는 굉장히 간단합니다. 하지만 이를 어떠한 방법들이 있었고 그 방법을 선택한 배경이라든지, 그 동기화처리를 어떻게 관리할 것인지에 대한 고민이 매우 중요하지 않나 생각듭니다. 여러분들께서도 이런 부분들을 잘 정리하여 두시면 많은 이점이 있을 것으로 사료됩니다.
* 모두가 이해할수 있도록 작성하려고 노력을 많이 했습니다. 모두에게 많이들 와닿고 쉽게 이해되는 글이 되었으면 합니다.
* 지금껏 알게 된 내용들을 본인의 프로젝트에도 적용하셔서 성능의 극대화를 이뤄내시기를 진심으로 기원합니다.
* 우리 모두 성능을 지배하는 개발자가 되도록 합시다.
* 1탄, 2탄에 거친 긴 글 읽어주셔서 진심으로 감사드립니다.
